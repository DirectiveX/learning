# 说一说jvm的内存模型

（这个问题比较大，啥都可以说，想到啥说啥）

总：jvm总共分为三个部分，类加载器，运行时数据区域和执行引擎

分：

> 对于类加载器，在进行类的第一次访问的时候，如果当前类没有被加载到内存，那么就会使用类加载器进行加载。类加载器有四种，分别为BootStrapClassLoader（启动类加载器），主要用于加载rt下面的类，还有ExtClassLoader（扩展类加载器），主要是加载引入的jar包，还有ApplicationClassLoader（应用类加载器），主要是加载当前app中的类，最后一类是自定义类加载器，可以通过继承ClassLoader类实现对应的findClass来实现自己的类加载器。
>
> 类加载器的类加载过程大的来说分为三步：加载，链接，初始化
> 在加载阶段，通过类加载器将当前类的字节码从磁盘加载到内存中，加载时使用类加载器的双亲委派机制对类进行加载
> 在链接阶段，分为三小步，第一步，验证阶段，验证当前加入到内存中的数据是否正确（比如开头是否有魔数CAFE BABE，后面是否是java的大版本信息major info，后面是否有java的小版本信息，再后面是否有常量池的大小，后面是否有常量池的具体内容，后面是否有访问修饰符，后面是否有当前类名，后面是否有当前父类名，后面是否有接口数量，后面是否有具体接口内容，后面是否有属性（field）数量，后面是否有具体的fields，后面是否有方法数量，后面是否有具体的方法，后面是否有attribute属性数量，后面是否有具体的attribute），第二步，准备阶段，主要做的工作是对当前类中的静态属性附初始值，第三步解析阶段，主要的工作是将当前的符号引用转换为对应的直接引用
> 在初始化阶段，执行对应的静态代码块和静态属性，给对应的属性附默认值
> 至此，类加载过程陈述完毕

> 对于运行时数据区域，分为两大块，5小块，分别为线程共享的堆和方法区，还有线程私有的本地方法栈和虚拟机栈还有程序计数器
>
> 先讲堆吧，堆中存储的是实例化的对象，然后是方法区，方法区主要存放的是类的元数据和常量池，然后是虚拟机栈，虚拟机栈中存放栈帧（栈帧的具体内容为：本地变量表（用于存放当前方法中的对象引用和变量的），操作数栈（用于计算的），动态链接（用于指向对应的元数据类对象），还有返回地址（指向返回的具体内存的位置）），然后是本地方法栈，本地方法栈中存放的是调用native方法，即非java原生实现的方法时，产生的引用和变量（在汇编中，以ESP表示栈顶，以EBP表示栈基址（即栈底），构成一个本地方法栈），然后是PC程序计数器，用于指向下一个指令要执行的具体位置（在汇编中表示就是CS：EIP）

> 对于执行引擎，又分为三大块，分别为解释器，编译器，GC
>
> 在java中，解释器分为两种，一种是汇编解释器，一种是c语言解释器
>
> 编译器我们一般聊的是即时编译器（JIT just in time），即时编译器通过对热点代码进行编译，编译成本地代码，更好的优化了java的执行速度（具体优化是这样的，即时编译器存在两个计数器，一个是用于对方法进行计数的方法计数器，一个是用于对代码块计数的回边计数器，当计数器到达一定数量（默认1w），那么即时编译器就会进行编译执行将方法或者代码块编译成本地方法）
>
> java有三种运行模式，即纯编译模式（适用于追求极致运行性能的），纯解释模式（启动速度快），mixed混合模式（默认模式）
>
> 然后就是GC的内容了，java通过垃圾回收机制来进行自动的垃圾回收，对应的存在一些垃圾标记算法如根可达性算法和标记计数法，然后对应存在一些垃圾清除算法比如复制算法，标记-清除，标记-整理，还有分代回收算法。具体GC的内容要讲起来就太多了，就这么简述一下吧

# 讲一讲堆内存空间的分配，如何回收这些对象，有哪些回收算法

在过去，人们将堆内存分为两大块，新生代和老年代，比例默认1：2，然后新生代中存放的是年龄较小的，较容易被回收的对象，老年代中存放的是那些年龄较大的，不容易被回收的对象，新生代又分为三块区域，即eden区和survivor0与survivor1区，因为新生代使用复制算法，所以需要survivor0和survivor1来支持，它们的比例是8：1：1

对于新生代的对象，回收的时候使用复制算法，即先找出当前内存中依旧活跃的对象，然后将这些对象复制到当前未使用的另外一个survivor中，修改指针引用，然后删除所有其他对象。对于老年代的对象，使用标记整理或者标记清除算法，即先进行活跃对象的标记，然后清除掉其他不活跃的对象，这是标记清除算法，但是标记清除算法会导致内存碎片化，所以标记整理算法再清除算法上做了一个增强，把活跃对象往前挪动，让后面区域形成连续的内存区域。

# 为什么过去GC分成老年代和新生代？

因为新生代和老年代对象的特点有巨大差异，新生代对象朝生夕死，迭代更新频繁，不容易存活，要经常进行回收，而老年代都是稳定对象，不需要被经常回收扫描，如果频繁扫描，就会浪费GC的性能

并且新生代和老年代用的算法不一样，新生代用复制算法，因为对象较少，老年代用标记整理或者标记清除算法，因为存活对象较多

# 为什么jdk1.8的时候将永久代（permgen）换成了元空间（metaspace）

早先的时候永久代是在堆中的，需要我们自己去分配空间，如果分配的大了堆容易OOM如果小了又不够用，不好处理，所以高版本直接将永久代移除，加入了元空间，元空间使用直接内存，不需要再担心影响堆的内存了，一般会设置一个元空间的最大大小，防止过度占用操作系统的资源

# 如何解决线上GC频繁的问题

GC频繁可能产生的原因有多种

1.首先最简单的，可以看下是不是由于代码patch到线上导致的，如果之前一直没有问题现在突然出问题了，那肯定是刚上线的代码出了问题，很容易进行解决

2.如果不是上线的代码问题，那么就需要查看当前jvm的参数设置（使用java +XX:+PrintCommandLineFlags），并且使用jmap -dump对内存进行转储，获取转储文件

3.将转储文件用jconsole或者jhat或者jvisualvm进行分析，分析出在哪个时间点，哪个对象数量较多（jmap -histo）导致频繁GC，或者哪个时间点对象其实都不多，但就是频繁full gc，可能是有人显示调用了system.gc的方法，配置参数去禁用它

4.找到对应产生对象的线程，根据线程名称去找对应的方法，定位到方法上来，解决问题

# 描述一下class的初始化过程

（注意这里是类初始化，不是对象初始化）

类的初始化就是有父类先初始化父类的静态代码块和静态成员属性，再初始化子类的静态代码块和静态成员属性，按照从上往下有序进行初始化。类的初始化过程是线程安全的。

# 内存溢出的原因以及如何排查线上问题

内存溢出的原因有多种

1.由于栈内存不足导致内存溢出，由于堆内存不足导致内存溢出，由于当前无法分配本地线程导致内存溢出，由于当前直接内存不足导致内存溢出，由于方法区（元空间）内存不足导致内存溢出，由于使用了98%的时间却没有回收掉2%以上的内存导致内存溢出。

如何排查线上问题

1.首先一般我们运维都会添加一个jvm启动参数叫做DumpOnOutOfMemory，添加了这个参数之后，如果产生OOM错误，就会将当时的堆转储出来

2.我们拿到当时堆的转储文件之后，可以使用jvisualvm或者jconsole，甚至于jhat对这个转储文件进行分析，分析当前到底是哪个对象特别大或者哪个类的对象特别多从而直接导致了OOM错误

3.找到对应的对象之后，可以定位到对应的线程，找打线程的名字，一般我们在创建线程池的时候，会重写线程工厂，然后给线程命名，所以通过定位到对应的线程名之后就可以定位到对应的方法，根据具体方法进行分析，到底是哪边代码出的问题

--------

（这边写的相对具体，当然不是我自己背的，抄一下）

1.Java.lang.OutOfMemory: java heap space

堆溢出，很有可能是代码问题

2.Java.lang.OutOfMemory: GC over head limit exceeded

GC回收效果太差，报错，可能是真的内存分配的不够，需要重新设置堆大小，也有可能是对象引用不当

3.Java.lang.OutOfMemory: unable to create new native thread

无法创建本地线程，可能是由于堆外内存不足

4.Java.lang.OutOfMemory: MetaSpace

估计是哪个憨憨的代理对象无限制生成，动态加载

5.Java.lang.OutOfMemory: Direct buffer memory

直接内存溢出，可能是使用了allocate方法但是忘记释放（free）了，常见的是使用netty的时候，没有调用释放方法（这边可以提一嘴用linux的pmap去找映射关系，不过还是不要嘴贱了）

6.Java.lang.StackOverFlow

栈溢出，-Xss设置的太小

-------

# JVM有哪些垃圾回收器，实际中如何进行选择

总：

JVM一共有十种垃圾回收器，3+3+4

首先是新生代的垃圾回收器serial，parallel scanvage，parNew

然后是老生代的垃圾回收器serial Old，parallel old，CMS

然后从G1开始没有新生代老生代的概念了，当然G1在逻辑上还是有新生代老生代的概念的，从G1开始的四种分别为G1,ZGC,Shenandoan和Epsilon

分：

> 其中serial是串行垃圾回收器，它使用的算法是复制算法
>
> parallel scanvage是并行垃圾回收器，它使用的算法是复制算法
>
> parNew是并行垃圾回收器，它使用的算法是复制算法，它是parallel的改进，主要是为了与CMS结合做了一些增强
>
> serial old是串行垃圾回收器，它是serial的老年代版本，使用的算法是标记-整理算法
>
> parallel old是parallel scanvage的老年代版本，是并行垃圾回收器它使用的算法是标记-整理算法
>
> CMS（concurrent mark swap），是并发垃圾处理器，它使用的算法是标记-清除算法
>
> 到了G1,ZGC,Shenandoan，都是并发垃圾处理器，与CMS的最大不同在于并发标记算法的不同
>
> （简单提一嘴，CMS的并发标记算法使用的是三色标记+增量更新，而G1使用的标记算法是三色标记+satb（snapshot at the begining），而ZGC并发标记算法使用的是着色指针+satb+读屏障，而Shenandoan使用的算法是转移指针+写屏障）

第二个问题

总：

在我们实际运用中会用到各种GC的组合，比如说serial + serial old，parNew + CMS （+ serial），parallel scanvage + parallel Old等

当然实际过程中会根据当前的内存情况来进行选择，如果当前服务器内存只有几十兆，就用serial + serial old足矣，当然一般肯定不会那么小，所以我们一般选用的就是ps+po的组合或者parNew +CMS的组合，这两个组合适用的内存大小其实差不多，所以一般使用的时候我们都会根据当前的应用类型进行一个选择，比如说做计算的，那么肯定希望吞吐量高一点，那么ps+po可以设置停顿时间，增加吞吐量，是更好的选择，而比如说做网页的，那对响应时间肯定有追求，最好还是选用parNew + CMS，当然这只是以上两种的对比，如果内存足够大（上百G），使用G1也是个不错的选择，并且G1目前已经很成熟了，如果内存到达几个T，那么就只能够使用ZGC了

-------------------

讲个故事，这是一段关于parNew和parallel scanvage的爱恨情仇的故事

当时开发parNew的时候，有个大佬不想用，觉得开发的不行，就自己写了一个parallel scanvage，然后提交上去经过测试，发现确实不错，就放进来了，而在开发parallel old的时候，那个大佬也加入了，所以parallel old只有一个，而新生代版本有两个

------------------------------

# 关于并行和并发还有吞吐量的计算

并行是任务同时执行，而并发是看起来像是同时执行，实际上只是线程间互相切换，也就是多线程（调度执行）

在GC的语境中，并发就是指垃圾回收线程与工作线程切换执行，而并行就是指垃圾回收线程之间多线程执行

吞吐量=程序执行时间/（程序执行时间+垃圾回收占用时间）

# 对G1（Garbage first）收集器有了解吗，有什么特点

总：有了解，G1的特点是可以预测响应时间，然后它是逻辑上分新生代和老年代的，但是物理上不分，物理上将区域分为一个一个region，每个region大小相等，它的并发标记算法使用的是三色标记+satb，它的垃圾收集算法使用的是复制算法

分：

G1如何实现响应时间的预测，G1中有一个CSet（Collection Set），里面存放着要被回收的region，然后每次进行垃圾区域回收划分的时候，会从中取一部分回收效率较高的部分，也就是垃圾较多的，进行回收，G1通过控制这个CSet的大小，对暂停响应时间进行一个预测

>  G1的执行流程为：①初始标记（标记根节点，产生stw）②并发标记（三色标记标记活跃对象，使用satb记录漏标的对象）③最终标记（stw）④复制清除（stw）

G1在复制的时候，会从CSet中选取一块区域，然后将该区域上的活跃对象复制到空闲区域，然后清除回收区域

（可以简单讲一下三色标记算法，emmm比较麻烦，面试问的话就讲一下，三色标记算法主要是三种颜色黑，灰，白，我们定义黑色表示当前结点已经被扫描过，并且它的子节点也都被扫描过，灰色表明当前结点已经被扫描过，但是它的子节点还未被扫描过，白色代表它和它的子节点都没被扫描过，然后我们只需要在结束的时候，判断当前结点的颜色，就可以判断出当前结点是否为活跃对象，那么为什么要用satb呢，因为存在情况可能产生漏标，需要用satb来解决，由于当前GC线程与工作线程是并发执行的，所以有可能出现这么一种情况，就是一个灰色结点的子节点在标记的时候断开了，并且它断开后，又被一个黑色结点引用了，如果不做特殊处理，那么这个子节点将永远无法被GC线程访问，就会被认为是一个无用对象，在进行垃圾回收的时候会进行一个回收，但是实际上这个对象是不需要被回收的，所以需要解决这个问题。解决这个问题的话只要解除掉任意一个条件即可，有两种解决方案，第一种是在黑色结点指向之前断开的结点时进行变色，把黑色结点变回灰色结点，这样GC线程就会再扫它的子节点，这是CMS使用的做法，也叫做增量更新，第二种解决方案就是satb，指的是在灰色结点断开的时候将断开的指针保存到snap queue中，在后面的最终标记阶段，会保证在这个queue中的对象依然是活跃的，不会误删除）

# 介绍一下垃圾回收算法

(注意是垃圾回收算法，这边不要去讲标记算法)

总：垃圾回收算法有三种，复制算法，标记-清除，标记-整理

分：

复制算法：存在一块空闲区域，然后从内存中找出对应的存活对象，将这些存活对象复制到空闲区域中，并且修改引用地址，新生代常用

标记-清除：就是先对活跃对象进行标记，然后第二遍的时候进行扫描，清除未被标记的对象，这种方法相对于标记整理速度较快，但是会产生内存碎片化的问题（CMS使用）

标记-整理：就是先对活跃对象进行标记，然后把活跃对象向一端移动，等到都移动完了，剩下的区域进行清理，这样就不会产生内存碎片化了，有连续的内存地址了（serial old和parallel old使用）

# Happens-Before规则？（这个我不会！能背多少背多少吧，答不出就死给他看）

（妈的出名词了，其实很简单，一言以蔽之就是as-if-serial，保证单线程下的执行结果的最终一致性）

1.程序执行规则：通俗点讲就是同一变量操作先后有序，不能进行重排序

2.锁规则：释放锁不能重排序后先于加锁

3.volatile变量规则：内存屏障保证volatile的变量不会被重排序

4.传递性规则：A happens-before B，B happens-before C，那么A happens-before C

5.线程启动规则：Thread对象的start方法早于该线程执行的任何一个动作

6.线程终止规则：线程所有的操作都必须早于线程终止（线程终止可以通过isAlive进行判断）

7.线程中断规则：interrupt的方法调用早于中断检测

# 描述类加载和初始化的过程（这里比上面讲的稍微全一点）

类加载器的类加载过程大的来说分为三步：加载，链接，初始化
加载阶段：
通过类加载器将当前类的字节码从磁盘加载到内存中，加载时使用类加载器的双亲委派机制讲=将类加载到内存，在内存中生成该类的java.lang.Class对象，后续可以通过这个对象访问方法区

在链接阶段，分为三小步，第一步，验证阶段，验证当前加入到内存中的数据是否正确（四步：文件格式验证，元数据验证（符合java语言规范），字节码验证（程序语义合法），符号引用验证），第二步，准备阶段，主要做的工作是对当前类中的静态属性附初始值，第三步解析阶段，主要的工作是将当前的符号引用转换为对应的直接引用

在初始化阶段，执行对应的静态代码块和静态属性，给对应的属性附默认值

（使用阶段：互相调用
销毁阶段：由垃圾回收器来完成）

# 什么叫做阻塞队列的有界和无界

阻塞队列：

- ArrayBlockingQueue：一个由**数组**结构组成的**有界**阻塞队列
- LinkedBlockingQueue：一个由**链表**结构组成的**无界（这边是相对无界，实际上它也不会进行动态扩容，但是不设置大小的时候默认Integer.MAX_VALUE，所以认为无界）**阻塞队列
- PriorityBlockingQueue：一个**支持优先级排序**的**无界**阻塞队列（小根堆+比较器）
- DelayQueue：一个**使用优先级队列**实现的**无界**阻塞队列
- SynchronousQueue：一个不存储元素的阻塞队列
- LinkedTransferQueue：一个由**链表**结构组成的**无界**阻塞队列
- LinkedBlockingDeque：一个由**链表**结构组成的**双向**阻塞队列

(有界与无界的区别在于是否能够进行扩容操作)

## ArrayBlockingQueue和LinkedBlockingQueue
- ArrayBlockingQueue 实现简单，表现稳定，添加和删除使用同一个锁，通常性能不如后者
- LinkedBlockingQueue 添加和删除两把锁是分开的，所以竞争会小一些

##  SynchronousQueue特点
容量等于0的队列

# JVM监控系统是通过jmx做的吗？

是，通过Java Management Extensions接口获取到jvm的信息，进行监控

# 内存屏障的汇编指令是啥

在X86里面，有三种内存屏障，读屏障lfense，写屏障sfense，全屏障mfense

# 怎么提前避免内存泄漏

写代码的时候注意一点，尽早释放无用对象，用完threadLocal记得调用remove方法

# 垃圾标记算法

总:垃圾标记算法分两种,引用计数法和可达性分析

分:

引用计数法就是当对象每被引用一次,引用计数加一,不引用了,计数就减一,如果计数为0,就为不可用对象,缺点是循环引用,造成无法正确回收

可达性分析,就是从根节点出发,向下寻找,找到从根节点出发的所有活跃对象,找不到的就是无用对象.根节点有四种,分别为java虚拟机栈中的引用,本地方法栈中的引用,方法区常量池的引用和方法区静态成员变量的引用

