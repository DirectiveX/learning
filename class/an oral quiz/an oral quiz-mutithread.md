# 如何预防死锁

要预防死锁先得了解，死锁产生的条件

>1.请求与保持：线程请求到的资源，在等待的时候会保持，不会释放
2.不剥夺：线程占有资源在使用完之前，不会被其他线程剥夺
3.循环等待：多个线程间互相等待对方释放资源，形成循环
4.互斥条件：同一时刻只能由一个线程获取资源

以上是充分必要条件，所以只要打破其中一种就可以预防死锁

> 1.（最出名的就是使用银行家算法）（有一张资源分配表，对资源进行一个分配，不够的时候进行等待，保证分配资源后是一个安全状态（非死锁状态））（加分项，不是标准答案）
> 2.互斥条件无法打破，不考虑
> 3.打破请求与保持：通过资源一次性分配来打破，这样在允许过程中不会再因为需要新资源而产生等待了
> 4.打破不剥夺：在程序运行中，如果请求资源的时候不能立即获取，那么就放弃当前已经获取到的资源，让资源回归
> 5.打破循环等待条件：给资源编号，按照顺序分配资源

# 线程有哪些创建方式？
1.继承Thread类，实现run方法
2.实现runnable接口，实现run方法
3.实现callable接口，实现call方法，这边可以有返回值（返回类型为Future类型，一般我们用FutureTask去接收它，它实现自RunnableFuture接口，是一个组合接口，组合了Runnable和Future，这个类能够异步获取执行结果）（加分项）
4.使用线程池进行创建

# 描述一下线程安全活跃态问题，竞态条件
总：安全活跃态指死锁活锁和饥饿
分：
1.死锁就是指由于多个线程抢占互斥资源产生的循环等待的状态
2.活锁就是线程一直在执行，但是一直达不到结束条件，进而一直重复尝试（消息中间件的延时重试机制）（解决：等待一个随机时间）（扩展：raft协议，raft选主）
3.饥饿就是指一个线程由于一直被其他线程抢占资源，无法获取资源进行执行，导致饥饿（常见的情况是读写锁，读优先的情况下，读特别多，写线程就饥饿了）（解决，公平锁）（扩展：cpu调度规则，分为时间片调度算法和优先级调度算法）

竞态条件就是指多线程访问同一资源，对资源的访问顺序敏感，称为竞态条件（简单的说就是由于没有加锁，输出的时机不可预测，可能产生结果覆盖，并且结果也不可预测），导致竞态条件发生的代码区称作临界区，在临界区使用锁能够避免竞态条件

# java的wait和sleep有什么区别和联系
区别
1.关于锁方面，wait释放锁（因为锁是对象上的），sleep不释放锁（因为sleep是线程的东西，和锁没关系）
2.关于等待时间方面，sleep一定要写等待时间，wait不一定，随意
3.关于作用域方面，wait必须要在外面加synchronize锁，它与对象相关，所以是绑定在Object上的，sleep在任何线程中都可以使用，因为它是绑定在Thread类上的

联系：
都可以使线程进入Timed_Waiting状态，都可以写入等待时间，都会导致线程阻塞
如果被中断，那么都会抛出中断异常，都需要捕获异常（notify，notifyAll不需要捕获异常）

# 描述一下进程与线程区别？
1.进程是操作系统资源分配的最小单位，线程是cpu进行资源调度的最小单位
2.进程由多个线程组成，进程之间的资源不共享，所以进程间通讯需要依靠消息队列，管道，信号量进行通讯，而线程间资源共享，所以线程间的通讯方式通过共享变量，锁，不管是synchronize锁还是reentrant lock等，还有wait和notify，join的方式进行通讯

（装逼内容：在linux中，如果一个进程他需要开启一个子进程，会调用fork方法，而使用fork方法开启的子进程是数据隔离，写时复制的，所以数据不共享，linux内核中提供了另外一个方法叫做clone，clone会开辟一个共享资源的子进程，也就是线程，Linux的进程类叫做task_struct，没有线程类，这个类既做线程又做进程）

# 描述一下java线程的生命周期
总：java线程分为几种状态，NEW,RUNNABLE,WAITING,TIMED_WAITING,BLOCKED,TERMINATED
分：
1.NEW状态就是线程刚刚被创建的时候
2.线程调用了start方法，变成RUNNING状态，RUNNABLE状态中又分为Ready和Running，Ready是指正在等待cpu调度，Running是指已经获取了cpu的时间片，等到时间片用完又会变成Ready状态
3.线程调用了sleep方法或者带时间单位的wait，LockSupport.parkNanos方法，会进入TIMED_WAITING状态，等待时间结束或被唤醒转回RUNNABLE状态
4.线程调用了wait，lock，park方法进入WAITING状态，调用对应的唤醒方法进入RUNNABLE状态
5.线程由于争抢synchronize锁进入BLOCKED状态，争抢到了锁之后会回归RUNNABLE状态

（在linux内核中，线程只有三种状态，运行，阻塞，销毁，而java在与linux进行协调的时候，多规定了几个状态，java刚开始创建线程对象，此时linux中还没有创建线程，所以产生了NEW状态，等到linux中开辟了新线程，但是此时可能还未分得cpu时间片，所以产生了Ready状态，在进行阻塞的时候，分为IO阻塞和锁阻塞等，为了区分这些阻塞，把锁阻塞描述成BLOCKED，把其他阻塞描述成WAITING）

# 代码题，是否能够打印finish？
```java
public class TTT {
    static boolean a;

    public static void main(String[] args) throws InterruptedException {

        new Thread(()->{
            while (!a){

            }
            System.out.println("finish");
        }).start();
        Thread.sleep(2000);
        a = true;
	}
}
```
会，也不会
会的原因是在默认的编译器和解释器混合模式下，由于编译器的作用，进行了代码优化，所以判断只进行了一次，后面直接进入死循环
不会的原因是，如果采用纯解释执行模式，那么就不会产生编译器优化，也就不会产生问题了

而我们为什么用volatile也能解决这个问题，是因为编译器在对volatile字段进行处理时，不会进行优化，所以加了volatile也管用

# 程序开多少个线程合适
1.先用公式可以估计线程数量，是
线程数=cpu核心数\*（1+等待时间/计算时间）\* cpu利用率
即IO密集型的，那么设置为CPU核心数的2倍（一般折中处理）
CPU密集型的，设置为核心数，减少线程上下文切换
2.然后可以进行测试，慢慢调

# notify和notifyAll的区别
点出锁池和等待池的概念：
1.锁池（Entry Set）
> 锁池是指由于争抢synchronize的锁争抢失败，进入到锁池

2.等待池（Wait Set）
> 等待池是指调用了wait方法进入等待池，等待池中的线程不会参与锁竞争

notify是等待池中选一个去唤醒，notifyAll是唤醒所有等待池中的线程，这边的唤醒就是指将等待池中的线程放入锁池，然后所有线程开始抢锁，抢到锁的进行执行

# 描述一下synchronized和Lock的区别
1.synchronized可以锁的范围是方法和代码块，lock只能锁代码块
2.synchronizad它会让线程处于BLOCKED状态，而lock会让线程处于WAITING的状态
3.synchronized可以响应中断，lock无法响应中断，但是它有个方法叫lockInterruptly可以响应中断
4.synchronized是一个修饰符，而Lock是接口
5.synchronized是非公平锁，lock都可以
6.synchronized不能指定唤醒，lock可以通过Condition来实现指定唤醒