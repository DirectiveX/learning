# 1.谈谈Spring IOC的理解，原理与实现?

首先，spring ioc用英文全名解释为spring inverse of control，控制翻转，它是一种思想，将对象的管理交由给spring 容器去管理，不需要手动管理对象的生命周期。它的具体实现是DI，依赖注入。依赖注入有几种方式，分别为构造器注入，新版本spring推荐的，然后是setter注入，接口注入。

spring ioc是一种容器，具体表现为singletenMap，说到IOC容器，就不得不说一下IOC的工作流程了

首先，spring会创建一个BeanFactory的实例，默认是DefaultLisableBeanFactory，然后会对xml和注解进行解析，用BeanDefinitionReader去解析它们，然后解析成BeanDefinition对象放入到容器中。然后创建对应的BeanFactoryPostProcessor以方便处理BeanDefinition对象，同时创建BeanPostProcessor（CommonAnnotationBeanPostProcessor用来解析PostConstruct和preDestory还有Resource注解）以方便后续处理Bean对象。然后用BeanFactoryPostProcessor（PlaceHolderConfigurerSupport，ConfigurationClassPostProcessor）对BeanDefinition进行一个增强，然后调用DefaultLisableBeanFactory进行对象的反射创建，使用getDeclaredConstructor().newInstance()方法。创建实例对象之后，要进行对象的初始化工作。首先是使用populateBean（）设置属性（这里面可以衍生出设置其他bean对象的属性，从而衍生出循环依赖，三级缓存），调用aware接口（BeanFactoryAware，BeanNameAware，BeanClassLoaderAware）的invokeAwareMethod方法，然后进行beanPostProcessor的before方法的调用，然后进入init-method方法的调用，在这个方法调用之前，还会判断一下是否实现了initializingBean的接口，如果实现就调用afterPropertiesSet方法，调用完毕initMethod方法后，进行后置处理器的after方法的调用（扩展点，在这边实现了aop的扩展功能），然后属性全部初始化完毕，放入容器，进行使用，用getBean方法获取对象。最后来到对象的销毁过程，当调用context.shutdown方法时会进行对象销毁，首先查看对象是否实现了DisposableBean接口，实现的话调用对应的destroy方法，然后再调用destroyMethod的指定的方法

以上就是Spring IOC的理解，原理与实现

# 2.Spring 是如何解决循环依赖的问题的？

这个问题首先要解释下循环依赖是怎么产生的，循环依赖的产生是因为A对象持有了B对象，然后B对象内部又持有了A对象，形成了一个闭环结构，导致循环依赖，只要形成闭环结构，就会产生循环依赖问题

循环依赖具体表现在创建A对象的时候，需要两大步，第一步，实例化对象A，此时A并没有初始化，然后进行初始化填充属性的时候，发现了B对象，先去容器中找是否有B对象，如果有那就没有循环依赖问题了，如果没有，那么就要开启B对象的一个创建过程，先实例化B对象，然后设置属性，设置A对象，然后去容器中找，此时依然找不到A对象，又会进行A对象的实例化，循环往复。要解决这个问题，主要抓住两个阶段之间的空隙，也就是实例化好A对象之后，可以提前暴露A对象，因为此时对象虽然没有完全初始化，但是对象的引用已经存在了，这样就可以在初始化B对象的时候，设置到A对象的属性，等过一会A对象填充完毕之后A和B就都能够使用了。spring是通过三级缓存来解决循环依赖问题的。三级缓存分别为SingletonsObjects，earlySingletonObjects还有singletonFactories，分别存放的最终对象，半成品对象，和对象的工厂，传入的是一个函数式方程，对于一些普通对象的循环依赖问题，其实只要二级缓存就能够完成，但是对于一些特殊对象，就比如代理对象的循环依赖问题，如果只用二级缓存的话，会出现一个beanName对应多个Bean实例的情况，也就是一个是刚刚实例化的对象，还有一个是代理对象，会导致程序报错，所以需要使用三级缓存，在正式获取对象的时候，来确定是否使用代理对象来代替普通对象，保证容器中只用一个对应的bean对象

三级缓存放置的时候先放置singletenFactories，也就是第三缓存，使用addSingletenFactory的方法，然后放入二级缓存，使用getSingleten方法，最后丢入一级缓存，初始化完毕，使用addSingleten方法，当然并不一定要按部就班，二级缓存有时候可以直接跳过

# 3.Bean Factory与FactoryBean有什么区别？

BeanFactory与FactoryBean首先他们的相同点就是都是用来创建bean实例并交由spring去管理的，但是BeanFactory创建的时候要走一整套bean的创建流程，也就是bean的生命周期。而FactoryBean创建的时候是按照自己的写法进行一个创建，然后通过实现FactoryBean接口的对应方法，将创建好的对象交给spring容器去管理，这就是他们两者的区别

# 4.Spring中用到的设计模式?

首先，单例模式，spring最著名的ioc容器默认就是单例模式，其次，原型模式，spring中的bean也可以设置scope，让他变成prototype，也就是原型模式，然后使用了观察者模式，spring大量运用了观察者模式，比如说，各种listener，通过发布event事件，进行一个muticast的广播，实现了观察者模式，还有责任链模式，在spring aop的时候用了一个拦截器链进行处理，还有工厂模式，三级缓存的bean工厂等，还有模板方法，onrefresh方法，beanpostprocessor方法，还有适配器模式，spring里面的各种Adapter都是适配器模式的，还有一种不属于23中设计模式的模式，叫做委托者模式，也使用的比较广泛，一般带delegator字眼的都使用了这种模式，还有代理模式，spring的aop是代理模式的一种标准使用

# 5.AOP是什么？

AOP是一种编程思想，它将业务逻辑与横切逻辑区分开来，让程序员更加集中于业务逻辑的开发，中间定义了一些具体的名词，有切面，切点，连接点，通知，织入，目标对象

切面是切点与通知的集合

切点是具体增强的部分

通知就是切面何时处理，after，before,around,afterThrowing,afterReturning

目标对象就是被代理的对象

连接点就是可以被增强的部分

织入就是指将切面织入到目标对象中并生成增强对象的过程

一般对于AOP的实现，可以在编译class的时候进行一个静态织入，例如AspectJ，也可以在程序运行时进行动态代理，例如Spring的AOP

# 6.Spring的AOP的底层实现原理?

先简单介绍一下AOP，AOP全名为面向切面编程，切面的主要功能就是将业务逻辑与横切逻辑区分开来，让程序员更加集中于业务逻辑的开发

spring的AOP的底层实现是依靠动态代理去实现的，它通过判断当前对象是否实现了interface接口，来判断使用何种方式进行一个aop的代理，如果实现了interface接口，那么就可以使用jdk动态代理，而如果没实现interface接口，那么只能使用cglib动态代理去进行一个代理实现，当然这只是往大了说，其实还是会受到配置文件影响的，并不是一旦实现interface就必须要用jdk的，还可能收到配置proxy- target-class的影响

底层的实现为
1.在进行配置文件或者注解的读取时，会准备好对应的beanDefinition
2.然后进行代理对象的创建的准备工作，比如说创建advisor，advisor是一个通知器，创建advisor的时候会调用它的有参构造函数，从而创建对应的advice对象，同样创建advice的时候也需要使用到有参构造器，创建它的三个属性，里面有AspectJExpressionPointCut，MethodLocationFactoryBean，SimpleBeanFactoryAwareAspectInstanceFactory
3.根据情况进行cglib或者jdk动态代理生成代理对象，并不是实现了接口就一定要使用jdk动态代理的，还受到一些属性值的影响，比如说，proxy-target-class，当然正常情况下，是实现接口jdk动态代理，不然使用cglib
4.生成完代理对象之后，在进行代理方法的调用的时候，会先调用到代理对象中的对应方法，然后找到DynamicAdvisedInterceptor中的intercept方法，进行调用。
5.会生成一条拦截器链，从链的头部开始调用，也就是index为-1的地方开始调用，先调用一个ExposeInvocationInterceptor的invoke方法，然后按照顺序依次调用MethodInterceptor的invoke方法，最后依次返回

# 7.为什么spring的@configuration修饰的类要使用代理？

因为@configuration中的bean可能会被手动调用，加上动态代理能够保证单独调用方法的时候会先从容器中获取，调用proxy.invokeSuper方法，如果有，从容器中获取，如果没有，才创建

# 8.Spring的事务如何进行回滚的？

spring中的事务机制依赖于aop来完成，但又有一点点不同，spring的事务在创建的时候并不是完全遵从于aop的定义的，他没有直接使用对应的advice，而是使用了TransactionInteceptor实现了MethodInteceptor接口，从而进行一个aop的执行工作。

事务执行过程如下：①准备工作，解析事务属性，根据传播特性来判断是否要开启新事务，或者报异常或者使用原来事务，或者挂起②要开启的话，打开连接，关闭自动提交，将连接持有器放入到本地线程中③进行具体业务逻辑的执行④如果执行报错，那么就进入completeTransactionAfterThrowing方法进行回滚处理，具体方法使用doRollback⑤如果没有出现异常，就进行commitTransactionAfterReturning方法进行一个提交，具体方法使用doCommit⑥事务执行完毕进行事务信息的清除

# 9.spring事务传播机制？

spring事务传播一共分为7种，3类，分别为required（默认的，有外层事务就用外层事务，没有就新建事务），support（有外层事务就用外层事务，没有就不用），mandatory（有外层事务就用外层事务，没有就报异常），required_new（不管外层是否有事务，都会新建事务，如果存在外层事务，就将外层事务挂起），not_support（不支持事务，如果外层事务存在，就挂起），never（不支持事务，如果外层事务存在，就报异常），nested（有外层事务，就用外层事务，同时创建保存点，没有外层事务，就新建一个事务）

常用的事务传播机制有required，required_new和nested

下面讲讲他们之间的组合

①required，required_new，nested存在外层，内层是required的情况，如果成功，就在外层一起提交，如果外层报错，内层与外层一起回滚，如果内层报错，内层与外层一起回滚

②required，required_new，nested存在外层，内层是required_new的情况，如果成功，内层先提交，外层再提交，如果外层报错，内层提交，外层回滚，如果内层报错，内层回滚，外层回滚

③required，required_new，nested存在外层，内层是nested的情况，如果成功，一起提交，如果内层失败，外层与内层一起回滚，如果外层失败，外层与内层一起回滚。如果外层对内层报错方法加入了try catch，内层失败，内层回滚，外层正常提交

required和nested异同

两者在外层有事务的时候都不会新开事务，不同之处在于，如果内层事务发生异常，抛出异常，require会设置回滚标记，导致就算在外层中捕获了对应异常，由于回滚标记的设置，外层事务仍然需要被回滚，而nested会清空回滚标记，所以如果外层事务捕获了内层异常，就可以正常提交外层事务了。两者的异常信息也不同

required_new和nested区别

nested如果存在外层事务，不会新开事务，只是开启保存点，在原事务上执行，而required_new不管外层是否有事务，都会开启新事务，nested会对外层事务的异常产生反应，可以与外层事务一起回滚，而required由于两个事务，无法做到这种效果
