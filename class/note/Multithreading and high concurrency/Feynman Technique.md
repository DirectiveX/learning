# 多线程与高并发

## synchronized

是一种可重入锁（指当前线程请求锁时如果已经持有该对象的锁，可继续获得锁，不然会导致死锁）。synchronized可以加在代码块上和方法上。synchronized表示当前代码块同时有且只有一条线程能够执行。当synchronized去请求获取对象锁时，对象上的monitor会检测当前计数是否为0，如果为0，就允许获得锁，否则检测当前线程是否已经持有当前对象的锁，如果已经持有，那么monitor计数再+1，否则进入等待。

synchronize在jdk1.6之前使用的是重量级锁，一直向操作系统申请锁，在jdk1.6之后实现了锁升级机制，在hotspot的实现代码中，锁升级的步骤是 无锁 到 偏向锁 到 自旋锁 到 重量级锁

偏向锁：在对象的对象头中保存了线程的id，如果下一次还是这个线程请求获取锁，那么就直接让这个线程运行，如果检测到其他线程访问，就进行锁升级（其他机制去处理）

自旋锁：自旋等待其他线程释放锁，如果超过自旋次数（默认为10）或者自旋锁数量过多（超过cpu核心数的一半），就升级为重量级锁

重量级锁：向操作系统申请锁，进入等待队列等待获取锁（需要进行用户态与内核态的转换，速度较慢）

## volatile

1.保证了线程之间的可见性
用总线嗅探和数据一致性协议来保证线程之间的可见性

总线嗅探：指cpu需要对高速缓存的数据进行有效性确认，与总线中的数据进行对比，如果不同，就设置为Invalid，这样下次取数据的时候就会直接从主内存中获取

数据一致性协议：通常指的是MESI，M为Modified，E为Exclusive，S为Shared，I为Invalid，从硬件角度来说就是cpu在对自己的高速缓存区进行数据修改时，需要通知其他共享这个数据的cpu去修改数据的状态，保证数据的一致性

2.防止了代码重排序
通过内存屏障来防止代码的重排序
JMM中定义的内存屏障有两种，分别为Store Barrier和Load Barrier，StoreBarrier用于在存储数据之后立即刷新到内存，LoadBarrier用于无效高速缓存的数据，重新从主内存读取
JMM中的volatile内存屏障策略
在volatile写之前加入storestore
在volatile写之后加入storeload
在volatile读之后加入loadstore
在volatile读之后加入loadload

## CAS
compare and swap
主要实现的功能就是有一个期望值，和一个更新值，当我的期望值与我所访问的地址的值相等时，就用更新值去更新对应地址的值，如果不相等，就放弃更新
主要用CAS实现的类有AtomicXXX类

CAS的ABA问题
就是指当t1线程去修改一个对象A时，时间片用尽，此时线程t2也用到当前的对象A，将当前对象A替换成对象B后进行了一系列操作，然后再把A放回去，结束线程t2，此时t1再去比较期望值A与地址中的A值，发现一样，仍然对A进行了更新操作，这就是ABA问题

如何解决ABA问题
可以通过使用AtomicStempReference类去包装对象，实际上就是用了一个版本号去标记对象是否为原版对象

## AQS
AQS是一个次级抽象类，它的父类抽象类是AbstractOwnerableSynchronizer, 父类抽象类中有个主要的属性用于记录当前占有锁的线程，用以实现可重入锁。
AQS是CLH锁的一种变体，CLH是一种基于单链表实现的公平自旋不可重入锁，它与CLH锁不同点在于，AQS使用了双向链表并且AQS的Node节点在自旋等待的时候，会调用LockSupport的park方法进行等待，在释放锁时会调用LockSupport的unpark方法对后继节点进行唤醒。
AQS的结构是双向链表+一个线程间可见的state属性，根据属性去判断当前锁是否被持有，通过CAS去操作state和双向链表的头尾节点
AQS的子类通过实现tryAcquire方法可以实现公平锁和非公平锁，在JDK1.9之后，AQS优化了指向头尾节点的指针，用VarHandle的CAS来操作对应的地址，直接操作二进制码，速度更加快
VarHandle就是一个指向地址的指针，提供了原子修改值的方法，并且能直接操作二进制码

## ReentrantLock
ReentrantLock是一种可重入的独占锁，ReentrantLock内部持有了AQS的锁的实现类，内部的Sync继承了AQS，然后NonFairSync和FairSync继承了Sync抽象类，实现了公平锁和非公平锁
非公平
NonFairSync的逻辑：
先判断当前线程是否能抢占到锁，如果可以抢占到就直接执行，不然就看看当前线程是否持有锁，如果持有就计数+1，如果不是当前线程正在持有就进入等待队列等待
FairSync的逻辑：
先判断当前队列中是否为空，如果为空就就抢占锁，如果不为空就看看是否是当前线程正在持有锁，如果是当前线程正在持有锁，就继续执行，不然就进入等待队列
Sync释放的时候会减少state，如果减到0就释放锁并且将独占锁的线程置为空，并且唤醒后继节点

## ThreadLocal
每个线程上都有一个threadLocals属性，维护了线程专属的本地变量，当使用set方法时，将ThreadLocal对象存入threadLocals属性中，取的时候从threadLocals中取
threadLocals是一个ThreadLocalMap对象，里面用数组存储了一组Entry对象，Entry中存储了具体值，get时通过当前对象的hash值去找到Entry的位置，返回对应的值
Entry是一个继承了弱引用的对象，它的key是一个弱引用，以达到一个防止内存泄露的效果，对于被回收的key而言，在ThreadLocalMap中就是一个老旧对象，在数组空间不足的时候会移除这些key为null的Entry

做事务

## 强软弱虚
强引用永远不会被垃圾回收器处理
软引用当内存不够的时候会被垃圾回收器回收，做缓存用
弱引用是当它被垃圾回收器扫描到的时候被回收，一般用在容器，ThreadLocalMap中的Entry对象的key用的是软引用，弱引用通过get方法能获取对象
虚引用是随时会被回收，并且回收的时候会将引用放在队列中通知用户,虚引用通过get方法不能获取对象，是用来清理堆外内存（直接内存）（DirectByteBuffer）（用Unsafe去处理堆外内存 freeMemory）

## ForkJoinPool
ForkJoinPool基于工作-窃取理论来实现，通过将大任务分成一个个子任务进行执行，并将子任务汇总得出最终的结果。
ForkJoinPool通过继承自定义任务类型RecursionAction创建递归任务，分块执行，它的每个线程都维护了一个自己的任务队列，当有任务时执行队列中的任务，无任务时从别的线程任务队列尾部偷取一个进行执行，减小了其他线程的压力

## JMH
java microbenchmark harness
是一个java微基准测试工具，通过对方法进行单独的测试生成易读的测试报告，通过注解控制测试流程
常用的注解有
@Benchmark
需要被测试的方法
@Warmup
预热，让JIT将常用方法做成本地方法，防止测试出现误差
@Mesurement
真正的测试注解，描述了测试需要执行几次，一次执行多少秒
@Fork
需要展开多少个进程进行测试
@Threads
需要多少个线程进行测试

## Disrupter
Disrupter是目前单机下性能最高的队列。它的特点是无锁CAS，环形队列，使用了观察者模式实现了生产者消费者模型。它的核心就是一个环形队列，环形队列的底层是一个数组和一个指向下一个能够使用的位置的索引sequence，生产者在生产的时候向环形队列中放入Event事件，消费者消费的时候创建线程并调用EventHandler中实现的onEvent方法进行消费。生产者生产的时候可以选择多线程生产和单线程生产，默认多线程生产会对sequence操作的时候进行加锁，所以如果单线程的生产者指定一下Producer.SINGLE会提高性能。当sequence超出数组大小时会进行取模运算，算出对应位置进行数据覆盖，数组强制要求2的幂次方，以方便用与运算代替取模运算。当环形队列满时，会执行等待策略，可以用自己自定义的等待策略，也可以用Disrupter自己提供的，默认是BlockingWaitStrategy, 阻塞等待唤醒，还有一些像LiteBlockingWaitStrategy，相较于BlockingWaitStrategy，在加锁时进行了简化操作，还有LiteTimeoutBlockingWaitStrategy，在LiteBlockingWaitStrategy的基础上添加了Timeout参数，一旦时间超出设定时间就停止阻塞，TimeoutBlockingWaitStrategy在BlockingWaitStrategy的基础上添加了Timeout参数，BusySpinBlockingWaitStrategy，自旋等待，SleepingWaitStrategy，睡一会再看是否能够执行，YieldingWaitStrategy，尝试100次后让出cpu，PhaseBackOffWaitStrategy，根据传入的时间点和等待策略分阶段执行等待策略