# 多线程与高并发

## synchronized

是一种可重入锁（指当前线程请求锁时如果已经持有该对象的锁，可继续获得锁，不然会导致死锁）。synchronized可以加在代码块上和方法上。synchronized表示当前代码块同时有且只有一条线程能够执行。当synchronized去请求获取对象锁时，对象上的monitor会检测当前计数是否为0，如果为0，就允许获得锁，否则检测当前线程是否已经持有当前对象的锁，如果已经持有，那么monitor计数再+1，否则进入等待。

synchronize在jdk1.6之前使用的是重量级锁，一直向操作系统申请锁，在jdk1.6之后实现了锁升级机制，在hotspot的实现代码中，锁升级的步骤是 无锁 到 偏向锁 到 自旋锁 到 重量级锁

偏向锁：在对象的对象头中保存了线程的id，如果下一次还是这个线程请求获取锁，那么就直接让这个线程运行，如果检测到其他线程访问，就进行锁升级（其他机制去处理）

自旋锁：自旋等待其他线程释放锁，如果超过自旋次数（默认为10）或者自旋锁数量过多（超过cpu核心数的一半），就升级为重量级锁

重量级锁：向操作系统申请锁，进入等待队列等待获取锁（需要进行用户态与内核态的转换，速度较慢）

## volatile

1.保证了线程之间的可见性
用总线嗅探和数据一致性协议来保证线程之间的可见性

总线嗅探：指cpu需要对高速缓存的数据进行有效性确认，与总线中的数据进行对比，如果不同，就设置为Invalid，这样下次取数据的时候就会直接从主内存中获取

数据一致性协议：通常指的是MESI，M为Modified，E为Exclusive，S为Shared，I为Invalid，从硬件角度来说就是cpu在对自己的高速缓存区进行数据修改时，需要通知其他共享这个数据的cpu去修改数据的状态，保证数据的一致性

2.防止了代码重排序
通过内存屏障来防止代码的重排序
JMM中定义的内存屏障有两种，分别为Store Barrier和Load Barrier，StoreBarrier用于在存储数据之后立即刷新到内存，LoadBarrier用于无效高速缓存的数据，重新从主内存读取
JMM中的volatile内存屏障策略
在volatile写之前加入storestore
在volatile写之后加入storeload
在volatile读之后加入loadstore
在volatile读之后加入loadload

## CAS
compare and swap
主要实现的功能就是有一个期望值，和一个更新值，当我的期望值与我所访问的地址的值相等时，就用更新值去更新对应地址的值，如果不相等，就放弃更新
主要用CAS实现的类有AtomicXXX类

CAS的ABA问题
就是指当t1线程去修改一个对象A时，时间片用尽，此时线程t2也用到当前的对象A，将当前对象A替换成对象B后进行了一系列操作，然后再把A放回去，结束线程t2，此时t1再去比较期望值A与地址中的A值，发现一样，仍然对A进行了更新操作，这就是ABA问题

如何解决ABA问题
可以通过使用AtomicStempReference类去包装对象，实际上就是用了一个版本号去标记对象是否为原版对象